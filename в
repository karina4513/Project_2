from flask import Flask, request, render_template
import requests
import plotly.express as px
import dash
from dash import html
from dash import dcc
from dash.dependencies import Input, Output
import pandas as pd

# Ваш ключ API AccuWeather
API_KEY = 'o8ZPQawzAGvfbT7ZsckcDADdDui4uIlG'

# Инициализация Flask приложения
app = Flask(__name__)

# Инициализация Dash внутри Flask
dash_app = dash.Dash(__name__, server=app, url_base_pathname='/dash/')

# Глобальная переменная для хранения списка городов
cities = []

import logging

# Настройка логирования
logging.basicConfig(level=logging.INFO)

def get_coordinates(city_name):
    url = f'http://dataservice.accuweather.com/locations/v1/cities/search'
    params = {
        'apikey': API_KEY,
        'q': city_name,
        'language': 'ru-ru'
    }

    try:
        response = requests.get(url, params=params)
        logging.info(f"Запрос к API для города: {city_name}, статус: {response.status_code}")

        if response.status_code != 200:
            return None, None, f"Ошибка при получении координат: HTTP статус {response.status_code}"

        data = response.json()
        if not data:
            return None, None, f"Нет данных о местоположении для города: {city_name.strip()}"

        return data[0]['GeoPosition']['Latitude'], data[0]['GeoPosition']['Longitude'], None

    except requests.exceptions.RequestException as e:
        logging.error(f"Ошибка при подключении к серверу: {str(e)}")
        return None, None, f"Ошибка при подключении к серверу: {str(e)}"



# Функция для получения ключа местоположения
def get_location_key(latitude, longitude):
    url = 'http://dataservice.accuweather.com/locations/v1/cities/geoposition/search'
    params = {
        'apikey': API_KEY,
        'q': f'{latitude},{longitude}',
        'language': 'ru-ru'
    }
    response = requests.get(url, params=params)
    if response.status_code != 200:
        return None

    data = response.json()
    return data['Key'] if 'Key' in data else None

def get_forecast(location_key):
    url = f'http://dataservice.accuweather.com/forecasts/v1/daily/5day/{location_key}'
    params = {
        'apikey': API_KEY,
        'language': 'ru-ru',
        'details': 'true',
        'metric': 'true'
    }
    response = requests.get(url, params=params)

    if response.status_code != 200:
        print(f"Ошибка при получении прогноза погоды: {response.status_code}, {response.text}")
        return None

    data = response.json()
    if 'DailyForecasts' not in data:
        print("Ошибка: Нет данных о прогнозе погоды")
        return None

    return data

def extract_weather_parameters(weather_data):
    try:
        temperature_celsius = weather_data['Temperature']['Maximum']['Value']
        wind_speed = weather_data['Day']['Wind']['Speed']['Value']
        humidity_percent = weather_data['Day'].get('RelativeHumidity', 'Не доступно')
        rain_probability = weather_data['Day'].get('PrecipitationProbability', 'Не доступно')
    except KeyError as e:
        print(f"Ошибка извлечения данных: {e}")
        return None

    return {
        'temperature': temperature_celsius,
        'humidity': humidity_percent,
        'wind_speed': wind_speed,
        'rain_probability': rain_probability
    }


@app.route('/', methods=['GET'])
def index():
    return render_template('index.html')


@app.route('/weather', methods=['POST'])
def weather():
    global cities  # Указываем, что мы используем глобальную переменную
    start_city = request.form.get('start_city')
    end_city = request.form.get('end_city')
    intermediate_cities = request.form.getlist('intermediate_city')

    # Собираем все города в один список
    cities = [start_city] + intermediate_cities + [end_city]

    # Проверка на пустоту списка
    if not cities or all(city.strip() == "" for city in cities):
        return render_template('result.html', weather_condition="Пожалуйста, введите хотя бы один город.")

    weather_data = {}

    for city in cities:
        # Получаем координаты для каждого города
        latitude, longitude, error_message = get_coordinates(city)
        if error_message:
            return render_template('result.html', weather_condition=error_message)

        # Получаем ключ местоположения
        location_key = get_location_key(latitude, longitude)
        if not location_key:
            return render_template('result.html',
                                   weather_condition=f"Не удалось получить ключ местоположения для {city}")

        # Получаем прогноз погоды
        forecast = get_forecast(location_key)
        if not forecast:
            return render_template('result.html', weather_condition="Ошибка при получении прогноза погоды")

        # Извлекаем данные о погоде
        weather_data[city] = [extract_weather_parameters(day) for day in forecast['DailyForecasts']]

    # Возвращаем результаты в шаблон
    return render_template('result.html', weather_data=weather_data)


dash_app.layout = html.Div([
    html.H1("Прогноз погоды для городов"),
    dcc.Input(id='city-input', type='text', placeholder='Введите название города'),
    html.Button('Добавить город', id='add-city-button', n_clicks=0),
    dcc.Dropdown(
        id='city-dropdown',
        options=[],  # Изначально пустой список
        value=None,  # Установите значение по умолчанию
        style={'width': '50%'}
    ),
    dcc.RadioItems(
        id='days-radio',
        options=[
            {'label': '1 день', 'value': 1},
            {'label': '3 дня', 'value': 3},
            {'label': '5 дней', 'value': 5}
        ],
        value=5,  # Значение по умолчанию
        labelStyle={'display': 'inline-block'}
    ),
    dcc.Checklist(
        id='weather-parameters',
        options=[
            {'label': 'Температура', 'value': 'temperature'},
            {'label': 'Скорость ветра', 'value': 'wind_speed'},
            {'label': 'Вероятность осадков', 'value': 'rain_probability'}
        ],
        value=['temperature'],  # Значение по умолчанию
        inline=True
    ),
    dcc.Graph(id='weather-graph')  # График для отображения погоды
])
# Глобальная переменная для хранения списка городов
cities = []

@dash_app.callback(
    Output('city-dropdown', 'options'),
    Output('city-input', 'value'),
    Input('add-city-button', 'n_clicks'),
    Input('city-input', 'value'),
    prevent_initial_call=True
)
def add_city(n_clicks, city_name):
    if n_clicks > 0 and city_name:
        # Добавляем новый город в список
        cities.append({'label': city_name, 'value': city_name})
        return cities, ''  # Возвращаем обновленный список городов и очищаем поле ввода
    return cities, ''  # Если кнопка не нажата, возвращаем текущий список
@dash_app.callback(
    Output('weather-graph', 'figure'),
    [Input('city-dropdown', 'value'),
     Input('days-radio', 'value'),
     Input('weather-parameters', 'value')]
)
def update_graph(selected_city, days, selected_parameters):
    if not selected_city:
        return px.line(title="Выберите город для отображения")

    # Получаем данные для выбранного города
    latitude, longitude, _ = get_coordinates(selected_city)
    location_key = get_location_key(latitude, longitude)
    forecast = get_forecast(location_key)

    # Извлекаем данные о погоде
    weather_data = [extract_weather_parameters(day) for day in forecast['DailyForecasts'][:days]]
    days_list = [day['Date'] for day in forecast['DailyForecasts'][:days]]

    # Проверка, что данные не пустые
    if not weather_data or len(weather_data) < days:
        return px.line(title="Нет данных для отображения")

    # Создаем DataFrame для построения графиков
    df = pd.DataFrame(weather_data)
    df['Date'] = pd.to_datetime(days_list)

    # Создаем график с выбранными параметрами
    fig = px.line(df, x='Date', y=selected_parameters,
                  title=f'Прогноз погоды для города {selected_city}',
                  labels={'value': 'Значение', 'variable': 'Параметр'},
                  markers=True)

    # Добавляем всплывающие подсказки
    fig.update_traces(mode='lines+markers', hovertemplate='%{x}: %{y:.2f}')

    return fig



if __name__ == '__main__':
    app.run(debug=True)


